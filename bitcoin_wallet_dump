#! /bin/sh
# by pts@fazekas.hu at Thu Oct  2 18:26:04 CEST 2014

""":" #bitcoin_wallet_dump: Dump bitcoin addresses and private keys.

type python2.7 >/dev/null 2>&1 && exec python2.7 -- "$0" ${1+"$@"}
type python2.6 >/dev/null 2>&1 && exec python2.6 -- "$0" ${1+"$@"}
type python2.5 >/dev/null 2>&1 && exec python2.5 -- "$0" ${1+"$@"}
#type python2.4 >/dev/null 2>&1 && exec python2.4 -- "$0" ${1+"$@"}
exec python -- ${1+"$@"}; exit 1

Requirements: Python (2.5, 2.6 or 2.7; doesn't work with <=2.4 or 3.x) and,
optionally, for the openssl(1) command-line tool (for decrypting encrypted
wallets).

bitcoin_wallet_dump can dump both compressed and uncompressed SHARE (Bitcoin
address) SECRET (Bitcoin private key) keys found in various wallets. The
output is an ASCII text file containing compressed and uncompressed, SHARE
(base58-encoded Bitcoin address) and SECRET (wif-encoded Bitcoin private
key) keys.

Supported input file formats:

* The wallet file saved by the Bitcoin Wallet
  (https://play.google.com/store/apps/details?id=de.schildbach.wallet&hl=en)
  Android app. The app saves the wallet encrypted. bitcoin_wallet_dump can
  detect it and will call the openssl(1) command-line tool (which will
  prompt the user for the password) to decrypt it. bitcoin_wallet_dump also
  supports dumping the decrypted wallet directly.

* Text files containing SHARE and SECRET strings, including the output of
  bitcoin_wallet_dump itself.

For each private key, the corresponding compressed and uncompressed
addresses (SHARE) will also be generated and dumped.

Please note that some tools accept only uncompressed addresses, and some
tools (such as the Bitcoin Wallet app for Android) display compressed
addresses.

TODO(pts): Add Python 2.4 compatibility (no hashlib).
"""

import hashlib
import os
import re
import subprocess
import sys

# --- Bitcoin crypto code.
#
# Based on:
# https://github.com/vbuterin/pybitcointools/blob/master/bitcoin/main.py
#
# TODO(pts): Remove unused code.

# Elliptic curve parameters (secp256k1)

P = 2**256 - 2**32 - 977
N = 115792089237316195423570985008687907852837564279074904382605163141518161494337
A = 0
B = 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)


def change_curve(p, n, a, b, gx, gy):
    global P, N, A, B, Gx, Gy, G
    P, N, A, B, Gx, Gy = p, n, a, b, gx, gy
    G = (Gx, Gy)


def getG():
    return G

# Extended Euclidean Algorithm


def inv(a, n):
    lm, hm = 1, 0
    low, high = a % n, n
    while low > 1:
        r = high/low
        nm, new = hm-lm*r, high-low*r
        lm, low, hm, high = nm, new, lm, low
    return lm % n

# Base switching
code_strings = {
    2: '01',
    10: '012356789',
    16: '0123456789abcdef',
    32: 'abcdefghijklmnopqrstuvwxyz234567',
    58: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
    256: ''.join(chr(x) for x in xrange(256))
}


def get_code_string(base):
    if base in code_strings:
        return code_strings[base]
    else:
        raise ValueError("Invalid base!")


def lpad(msg, symbol, length):
    if len(msg) >= length:
        return msg
    return symbol * (length - len(msg)) + msg


def encode(val, base, minlen=0):
    base, minlen = int(base), int(minlen)
    code_string = get_code_string(base)
    result = ""
    while val > 0:
        result = code_string[val % base] + result
        val /= base
    return lpad(result, code_string[0], minlen)


def decode(string, base):
    base = int(base)
    code_string = get_code_string(base)
    result = 0
    if base == 16:
        string = string.lower()
    while len(string) > 0:
        result *= base
        result += code_string.find(string[0])
        string = string[1:]
    return result


def changebase(string, frm, to, minlen=0):
    if frm == to:
        return lpad(string, get_code_string(frm)[0], minlen)
    return encode(decode(string, frm), to, minlen)

# Elliptic curve Jordan form functions
# P = (m, n, p, q) where m/n = x, p/q = y

def isinf(p):
    return p[0] == 0 and p[1] == 0


def jordan_isinf(p):
    return p[0][0] == 0 and p[1][0] == 0


def mulcoords(c1, c2):
    return (c1[0] * c2[0] % P, c1[1] * c2[1] % P)


def mul_by_const(c, v):
    return (c[0] * v % P, c[1])


def addcoords(c1, c2):
    return ((c1[0] * c2[1] + c2[0] * c1[1]) % P, c1[1] * c2[1] % P)


def subcoords(c1, c2):
    return ((c1[0] * c2[1] - c2[0] * c1[1]) % P, c1[1] * c2[1] % P)


def invcoords(c):
    return (c[1], c[0])


def jordan_add(a, b):
    if jordan_isinf(a):
        return b
    if jordan_isinf(b):
        return a

    if (a[0][0] * b[0][1] - b[0][0] * a[0][1]) % P == 0:
        if (a[1][0] * b[1][1] - b[1][0] * a[1][1]) % P == 0:
            return jordan_double(a)
        else:
            return ((0, 1), (0, 1))
    xdiff = subcoords(b[0], a[0])
    ydiff = subcoords(b[1], a[1])
    m = mulcoords(ydiff, invcoords(xdiff))
    x = subcoords(subcoords(mulcoords(m, m), a[0]), b[0])
    y = subcoords(mulcoords(m, subcoords(a[0], x)), a[1])
    return (x, y)


def jordan_double(a):
    if jordan_isinf(a):
        return ((0, 1), (0, 1))
    num = addcoords(mul_by_const(mulcoords(a[0], a[0]), 3), (A, 1))
    den = mul_by_const(a[1], 2)
    m = mulcoords(num, invcoords(den))
    x = subcoords(mulcoords(m, m), mul_by_const(a[0], 2))
    y = subcoords(mulcoords(m, subcoords(a[0], x)), a[1])
    return (x, y)


def jordan_multiply(a, n):
    if jordan_isinf(a) or n == 0:
        return ((0, 0), (0, 0))
    if n == 1:
        return a
    if n < 0 or n >= N:
        return jordan_multiply(a, n % N)
    if (n % 2) == 0:
        return jordan_double(jordan_multiply(a, n/2))
    if (n % 2) == 1:
        return jordan_add(jordan_double(jordan_multiply(a, n/2)), a)


def to_jordan(p):
    return ((p[0], 1), (p[1], 1))


def from_jordan(p):
    return (p[0][0] * inv(p[0][1], P) % P, p[1][0] * inv(p[1][1], P) % P)
    return (p[0][0] * inv(p[0][1], P) % P, p[1][0] * inv(p[1][1], P) % P)


def fast_multiply(a, n):
    return from_jordan(jordan_multiply(to_jordan(a), n))


def fast_add(a, b):
    return from_jordan(jordan_add(to_jordan(a), to_jordan(b)))

# Functions for handling pubkey and privkey formats


def get_pubkey_format(pub):
    if isinstance(pub, (tuple, list)): return 'decimal'
    elif len(pub) == 65 and pub[0] == '\x04': return 'bin'
    elif len(pub) == 130 and pub[0:2] == '04': return 'hex'
    elif len(pub) == 33 and pub[0] in ['\x02', '\x03']: return 'bin_compressed'
    elif len(pub) == 66 and pub[0:2] in ['02', '03']: return 'hex_compressed'
    elif len(pub) == 64: return 'bin_electrum'
    elif len(pub) == 128: return 'hex_electrum'
    else: raise Exception("Pubkey not in recognized format")


def encode_pubkey(pub, formt):
    if not isinstance(pub, (tuple, list)):
        pub = decode_pubkey(pub)
    if formt == 'decimal': return pub
    elif formt == 'bin': return '\x04' + encode(pub[0], 256, 32) + encode(pub[1], 256, 32)
    elif formt == 'bin_compressed': return chr(2+(pub[1] % 2)) + encode(pub[0], 256, 32)
    elif formt == 'hex': return '04' + encode(pub[0], 16, 64) + encode(pub[1], 16, 64)
    elif formt == 'hex_compressed': return '0'+str(2+(pub[1] % 2)) + encode(pub[0], 16, 64)
    elif formt == 'bin_electrum': return encode(pub[0], 256, 32) + encode(pub[1], 256, 32)
    elif formt == 'hex_electrum': return encode(pub[0], 16, 64) + encode(pub[1], 16, 64)
    else: raise Exception("Invalid format!")


def decode_pubkey(pub, formt=None):
    if not formt: formt = get_pubkey_format(pub)
    if formt == 'decimal': return pub
    elif formt == 'bin': return (decode(pub[1:33], 256), decode(pub[33:65], 256))
    elif formt == 'bin_compressed':
        x = decode(pub[1:33], 256)
        beta = pow(x*x*x+A*x+B, (P+1)/4, P)
        y = (P-beta) if ((beta + ord(pub[0])) % 2) else beta
        return (x, y)
    elif formt == 'hex': return (decode(pub[2:66], 16), decode(pub[66:130], 16))
    elif formt == 'hex_compressed':
        return decode_pubkey(pub.decode('hex'), 'bin_compressed')
    elif formt == 'bin_electrum':
        return (decode(pub[:32], 256), decode(pub[32:64], 256))
    elif formt == 'hex_electrum':
        return (decode(pub[:64], 16), decode(pub[64:128], 16))
    else: raise Exception("Invalid format!")

def get_privkey_format(priv):
    if isinstance(priv, (int, long)): return 'decimal'
    elif len(priv) == 32: return 'bin'
    elif len(priv) == 33: return 'bin_compressed'
    elif len(priv) == 64: return 'hex'
    elif len(priv) == 66: return 'hex_compressed'
    else:
        bin_p = b58check_to_bin(priv)
        if len(bin_p) == 32: return 'wif'
        elif len(bin_p) == 33: return 'wif_compressed'
        else: raise Exception("WIF does not represent privkey")

def encode_privkey(priv, formt, vbyte=0):
    if not isinstance(priv, (int, long)):
        return encode_privkey(decode_privkey(priv), formt, vbyte)
    if formt == 'decimal': return priv
    elif formt == 'bin': return encode(priv, 256, 32)
    elif formt == 'bin_compressed': return encode(priv, 256, 32)+'\x01'
    elif formt == 'hex': return encode(priv, 16, 64)
    elif formt == 'hex_compressed': return encode(priv, 16, 64)+'01'
    elif formt == 'wif':
        return bin_to_b58check(encode(priv, 256, 32), 128+int(vbyte))
    elif formt == 'wif_compressed':
        return bin_to_b58check(encode(priv, 256, 32)+'\x01', 128+int(vbyte))
    else: raise Exception("Invalid format!")

def decode_privkey(priv,formt=None):
    if not formt: formt = get_privkey_format(priv)
    if formt == 'decimal': return priv
    elif formt == 'bin': return decode(priv, 256)
    elif formt == 'bin_compressed': return decode(priv[:32], 256)
    elif formt == 'hex': return decode(priv, 16)
    elif formt == 'hex_compressed': return decode(priv[:64], 16)
    else:
        bin_p = b58check_to_bin(priv)
        if len(bin_p) == 32: return decode(bin_p, 256)
        elif len(bin_p) == 33: return decode(bin_p[:32], 256)
        else: raise Exception("WIF does not represent privkey")

def add_pubkeys(p1, p2):
    f1, f2 = get_pubkey_format(p1), get_pubkey_format(p2)
    return encode_pubkey(fast_add(decode_pubkey(p1, f1), decode_pubkey(p2, f2)), f1)

def add_privkeys(p1, p2):
    f1, f2 = get_privkey_format(p1), get_privkey_format(p2)
    return encode_privkey((decode_privkey(p1, f1) + decode_privkey(p2, f2)) % N, f1)


def multiply(pubkey, privkey):
    f1, f2 = get_pubkey_format(pubkey), get_privkey_format(privkey)
    pubkey, privkey = decode_pubkey(pubkey, f1), decode_privkey(privkey, f2)
    # http://safecurves.cr.yp.to/twist.html
    if not isinf(pubkey) and (pubkey[0]**3+B-pubkey[1]*pubkey[1]) % P != 0:
        raise Exception("Point not on curve")
    return encode_pubkey(fast_multiply(pubkey, privkey), f1)


def divide(pubkey, privkey):
    factor = inv(decode_privkey(privkey), N)
    return multiply(pubkey, factor)


def compress(pubkey):
    f = get_pubkey_format(pubkey)
    if 'compressed' in f: return pubkey
    elif f == 'bin': return encode_pubkey(decode_pubkey(pubkey, f), 'bin_compressed')
    elif f == 'hex' or f == 'decimal':
        return encode_pubkey(decode_pubkey(pubkey, f), 'hex_compressed')


def decompress(pubkey):
    f = get_pubkey_format(pubkey)
    if 'compressed' not in f: return pubkey
    elif f == 'bin_compressed': return encode_pubkey(decode_pubkey(pubkey, f), 'bin')
    elif f == 'hex_compressed' or f == 'decimal':
        return encode_pubkey(decode_pubkey(pubkey, f), 'hex')


def privkey_to_pubkey(privkey):
    f = get_privkey_format(privkey)
    privkey = decode_privkey(privkey, f)
    if privkey == 0 or privkey >= N:
        raise Exception("Invalid privkey")
    if f in ['bin', 'bin_compressed', 'hex', 'hex_compressed', 'decimal']:
        return encode_pubkey(fast_multiply(G, privkey), f)
    else:
        return encode_pubkey(fast_multiply(G, privkey), f.replace('wif', 'hex'))

def privkey_to_address(priv, magicbyte=0):
    return pubkey_to_address(privkey_to_pubkey(priv), magicbyte)

# Hashes

def bin_hash160(string):
    intermed = hashlib.sha256(string).digest()
    digest = ''
    try:
        digest = hashlib.new('ripemd160', intermed).digest()
    except:
        digest = ripemd.RIPEMD160(intermed).digest()
    return digest


def hash160(string):
    return bin_hash160(string).encode('hex')


def bin_sha256(string):
    return hashlib.sha256(string).digest()


def sha256(string):
    return bin_sha256(string).encode('hex')


def bin_dbl_sha256(string):
    return hashlib.sha256(hashlib.sha256(string).digest()).digest()


def dbl_sha256(string):
    return bin_dbl_sha256(string).encode('hex')


# Encodings

def bin_to_b58check(inp, magicbyte=0):
    inp_fmtd = chr(int(magicbyte)) + inp
    leadingzbytes = len(re.match('^\x00*', inp_fmtd).group(0))
    checksum = bin_dbl_sha256(inp_fmtd)[:4]
    return '1' * leadingzbytes + changebase(inp_fmtd+checksum, 256, 58)


def b58check_to_bin(inp):
    leadingzbytes = len(re.match('^1*', inp).group(0))
    data = '\x00' * leadingzbytes + changebase(inp, 58, 256)
    assert bin_dbl_sha256(data[:-4])[:4] == data[-4:]
    return data[1:-4]


def get_version_byte(inp):
    leadingzbytes = len(re.match('^1*', inp).group(0))
    data = '\x00' * leadingzbytes + changebase(inp, 58, 256)
    assert bin_dbl_sha256(data[:-4])[:4] == data[-4:]
    return ord(data[0])


def hex_to_b58check(inp, magicbyte=0):
    return bin_to_b58check(inp.decode('hex'), magicbyte)


def b58check_to_hex(inp):
    return b58check_to_bin(inp).encode('hex')


def pubkey_to_address(pubkey, magicbyte=0):
    if isinstance(pubkey, (list, tuple)):
        pubkey = encode_pubkey(pubkey, 'bin')
    if len(pubkey) in (66, 130):
        return bin_to_b58check(bin_hash160(pubkey.decode('hex')), magicbyte)
    return bin_to_b58check(bin_hash160(pubkey), magicbyte)

def is_corresponding(address, public_key):
  address_c = pubkey_to_address(encode_pubkey(public_key, 'bin_compressed'))
  address_u = pubkey_to_address(public_key)
  return address in (address_c, address_u)

# --- Tests for the Bitcoin crypto code above

def test_crypto():
  """Test data from: http://bitcoin.stackexchange.com/a/3839/19559 """
  privu = '5HwoXVkHoRM8sL2KmNRS217n1g8mPPBomrY7yehCuXC1115WWsh'
  assert get_privkey_format(privu) == 'wif'
  dprivu = decode_privkey(privu)
  assert dprivu == 7719472615821079694904732333912527190217998977709370935963838933860875309329
  dpubu = privkey_to_pubkey(dprivu)
  assert dpubu == (35826991941973211494003564265461426073026284918572421206325859877044495085994, 25491041833361137486709012056693088297620945779048998614056404517283089805761)
  pubu = '044f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa385b6b1b8ead809ca67454d9683fcf2ba03456d6fe2c4abe2b07f0fbdbb2f1c1'
  assert get_pubkey_format(pubu) == 'hex'
  assert encode_pubkey(dpubu, 'hex') == pubu
  daddru = pubkey_to_address(dpubu)
  assert daddru == '1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a'
  # There is no way to convert an address (e.g. daddru) back to a public or
  # private key. (That's because the address is computed from the public key
  # by hashing.)
  privc = 'KwntMbt59tTsj8xqpqYqRRWufyjGunvhSyeMo3NTYpFYzZbXJ5Hp'
  assert get_privkey_format(privc) == 'wif_compressed'
  assert decode_privkey(privc) == dprivu
  assert encode_pubkey(dpubu, 'hex_compressed') == '034f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa'
  assert encode_pubkey(dpubu, 'hex_electrum') == '4f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa385b6b1b8ead809ca67454d9683fcf2ba03456d6fe2c4abe2b07f0fbdbb2f1c1'
  assert pubkey_to_address(encode_pubkey(dpubu, 'bin_compressed')) == '1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9'


test_crypto()


# --- Parser of http://bitcoinj.googlecode.com/git/core/src/bitcoin.proto


class ProtoParseError(ValueError):
  """Input protocol message is invalid."""


class TruncatedError(ProtoParseError):
  """Input protocol message was truncated."""


def parse_varint(data, i, j):
  assert 0 <= i <= j
  u = 0
  shift = 0
  while True:
    if i >= j:
      raise TruncatedError
    if i >= len(data):
      raise TruncatedError
    c = ord(data[i])
    i += 1
    if c < 128:
      u |= c << shift
      return u, i
    u |= (c & 127) << shift  # LSB first.
    shift += 7


def parse_proto(data, start=0, end=None):
  if not isinstance(data, str):
    raise TypeError
  if end is None:
    end = len(data)
  if not (0 <= start <= end):
    raise ValueError, (start, end)
  i, j = start, end
  result = {}
  prev_tag = None
  while i < j:
    i0 = i
    u, i = parse_varint(data, i, j)
    tag = u >> 3
    type = u & 7
    tr = result.get(tag)
    if tag != prev_tag and tr is not None:
      # TODO(pts): Make groups work.
      raise ProtoParseError('Unexpected tag again.')
    if tr is None:
      tr = result[tag] = []
    if type == 2:  # Length-delimited.
      u, i = parse_varint(data, i, j)
      if i + u > j:
        raise TruncatedError
      # TODO(pts): Use the buffer type to avoid string copies.
      tr.append({'at': i0, 'ofs': i, 'data': data[i : i + u]})
      i += u
    elif type == 0:  # Varint.
      u, i = parse_varint(data, i, j)
      tr.append({'at': i0, 'varint': u})
    elif type == 3:  # Start-group.
      tr.append({'at': i0, 'start': True})
    elif type == 4:  # End-group.
      tr.append({'at': i0, 'end': True})
    elif type == 5:  # 32-bit.
      if i + 4 > j:
        raise TruncatedError
      u = struct.unpack('<I', data[i : i + 4])[0]
      tr.append({'at': i0, 'f32': u})
      i += 4
    elif type == 1:  # 64-bit.
      if i + 8 > j:
        raise TruncatedError
      u = struct.unpack('<Q', data[i : i + 8])[0]
      tr.append({'at': i0, 'f64': u})
      i += 8
    else:
      raise ProtoParseError('@%d tag=%d type=%d' % (i0, tag, type))
    prev_tag = tag
  return result


def get_required(msg, tag):
  v = msg.get(tag, None)
  assert v is not None
  assert len(v) == 1
  return v[0]


def parse_bitcoin_wallet_proto(data):
  TAG_WALLET_NETWORK_IDENTIFIER = 1
  TAG_WALLET_KEY = 3
  TAG_KEY_TYPE = 1
  TAG_KEY_PRIVATE_KEY = 2
  TAG_KEY_PUBLIC_KEY = 3
  ENUM_KEY_TYPE_ORIGINAL = 1

  msg_wallet = parse_proto(data)
  assert get_required(msg_wallet, TAG_WALLET_NETWORK_IDENTIFIER)['data'] in (
      'org.bitcoin.production', 'org.bitcoin.test')
  for data_key in msg_wallet.get(TAG_WALLET_KEY, ()):
    msg_key = parse_proto(data_key['data'])
    key_type = get_required(msg_key, TAG_KEY_TYPE)
    assert key_type['varint'] == ENUM_KEY_TYPE_ORIGINAL
    private_key = get_required(msg_key, TAG_KEY_PRIVATE_KEY)['data']
    # TODO(pts): Generate it from the private key if mossing.
    public_key = get_required(msg_key, TAG_KEY_PUBLIC_KEY)['data']
    pubkey_format = get_pubkey_format(public_key)
    assert pubkey_format in ('bin', 'bin_compressed')
    is_compressed = pubkey_format == 'bin_compressed'
    assert get_privkey_format(private_key) == 'bin'
    private_key = decode_privkey(private_key)
    public_key = decode_pubkey(public_key)
    assert privkey_to_pubkey(private_key) == public_key
    yield {'private_key': private_key,
           'public_key': public_key,
           'is_compressed': is_compressed,
          }

def parse_bitcoin_wallet_proto_enc_custom(data, extra_flags):
  # TODO(pts): Use `-pass', read passphrase in Python, customize prompt.
  p = subprocess.Popen(
      ('openssl', 'enc', '-d', '-aes-256-cbc') + tuple(extra_flags),
      stdin=subprocess.PIPE, stdout=subprocess.PIPE)
  plaintext_data = p.communicate(data)[0]
  exit_code = p.wait()
  if exit_code:
    raise RuntimeError(
        'openssl decryption failed with exit_code=%d' % exit_code)
  plaintext_format = detect(plaintext_data)
  if plaintext_format != 'bitcoin_wallet_proto':
    raise RuntimeError(
        'Unexpected plaintext format, expecting bitcoin_wallet_proto: %s' %
        plaintext_format)
  return parse_bitcoin_wallet_proto(plaintext_data)


def parse_bitcoin_wallet_proto_enc(data):
  return parse_bitcoin_wallet_proto_enc_custom(data, ())


def parse_bitcoin_wallet_proto_enc_base64(data):
  return parse_bitcoin_wallet_proto_enc_custom(data, ('-a',))


# From https://en.bitcoin.it/wiki/Private_key#Base58_Wallet_Import_format :
#
# WIF: For private keys associated with uncompressed public keys, they are
# 51 characters and always start with the number 5 on mainnet (9 on
# testnet). Private keys associated with compressed public keys are 52
# characters and start with a capital L or K on mainnet (c on testnet). This
# is the same private key in (mainnet) wallet import format.
PRIVATE_KEY_RE = re.compile(
    r'[59][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{50}\Z|'
    r'[LKc][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51}\Z')

# From https://en.bitcoin.it/wiki/Address :
#
# A Bitcoin address, or simply address, is an identifier of 26-34
# alphanumeric characters, beginning with the number 1 or 3 on mainnet (and
# m or n on testnet), that represents a possible destination for a Bitcoin
# payment.
#
# It's not possible to know whether an address is compressed or not.
ADDRESS_RE = re.compile(
    r'[13mn]'
    r'[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25,33}\Z')


BASE58_DATA_RE = re.compile(
    r'\s*(?:[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{26,52}'
    r'\s*)*\Z')


def parse_text(data):
  items = []
  prev_address = prev_private_key = None
  for line in data.splitlines():
    line = line.split()
    if not line:
      prev_address = prev_private_key = None
    if '#' in line:
      del line[line.index('#'):]
    if (not line or line[0].startswith('#') or
        line[0] == 'input_format:'):
      continue
    if PRIVATE_KEY_RE.match(line[-1]):
      private_key_format = get_privkey_format(line[-1])
      if private_key_format not in ('wif', 'wif_compressed'):
        raise ValueError(
            'Unexpected private key format, expecting wif*: %s' %
            private_key_format)
      private_key = decode_privkey(line[-1])
      public_key = privkey_to_pubkey(private_key)
      if is_corresponding(prev_address, public_key):
        assert items
        assert 'address' in items[-1]
        assert items[-1]['address'] == prev_address
        items.pop()
      if prev_private_key != private_key:
        items.append({'private_key': private_key,
                      'public_key': public_key,
                      'is_compressed': private_key_format == 'wif_compressed'})
      prev_address = None
      prev_private_key = private_key
    elif ADDRESS_RE.match(line[-1]):
      if prev_private_key is not None and (
          items and 'private_key' in items[-1] and
          is_corresponding(
              line[-1], privkey_to_pubkey(items[-1]['private_key']))):
        pass
      else:
        items.append({'address': line[-1]})
        prev_address = line[-1]
        prev_private_key = None
  return iter(items)


PARSERS = {
    'bitcoin_wallet_proto': parse_bitcoin_wallet_proto,
    'bitcoin_wallet_proto_enc': parse_bitcoin_wallet_proto_enc,
    'bitcoin_wallet_proto_enc_base64': parse_bitcoin_wallet_proto_enc_base64,
    'text': parse_text,
}


def detect(data):
  if (data.startswith('\n\x16org.bitcoin.production') or
      data.startswith('\n\x10org.bitcoin.test')
     ):
    return 'bitcoin_wallet_proto'
  elif data.startswith('Salted__'):
    return 'bitcoin_wallet_proto_enc'
  elif data.startswith('U2FsdGVkX1'):  # base64.b64encode('Salted__')[:10].
    return 'bitcoin_wallet_proto_enc_base64'
  elif (data.startswith('input_format:') or
        data.startswith('SHARE:') or
        data.startswith('SECRET:')):
    return 'text'
  elif BASE58_DATA_RE.match(data):
    return 'text'
  else:
    return 'unknown'


def main(argv):
  if len(argv) != 2:
    print >>sys.stderr, 'Usage: %s <input-filename>' % argv[0]
    sys.exit(1)
  filename = argv[1]
  if filename == '-':
    data = sys.stdin.read()
  else:
    data = open(filename).read()
  format = detect(data)
  print 'input_format: %s\n' % format
  if format == 'unknown':
    raise RuntimeError('Could not detect file format: %s' % filename)
  count = 0
  for bkey in PARSERS[format](data):
    private_key = bkey.get('private_key')
    address = bkey.get('address')
    public_key = bkey.get('public_key')
    is_compressed = bkey.get('is_compressed')
    if private_key is not None:
      private_key_format = get_privkey_format(private_key)
      assert private_key_format == 'decimal'
      public_key_gen = privkey_to_pubkey(private_key)
      if public_key is None:
        public_key = public_key_gen
      elif public_key_gen != public_key:
        raise ValueError(
            'Unexpected public key: expected=%s, got=%s' %
            (encode_pubkey(public_key, 'hex'),
             encode_pubkey(publig_key_gen, 'hex')))
    if public_key is not None:
      address_c = pubkey_to_address(encode_pubkey(public_key, 'bin_compressed'))
      address_u = pubkey_to_address(public_key)
      if address not in (None, address_c, address_u):
        raise ValueError('Unexpected Bitcoin address: %s' % address)
      if is_compressed:  # None and False re false.
        address = address_c
      else:
        address = address_u
    assert address is not None
    if is_compressed is None:
      print 'SHARE:', address
      if private_key is not None:
        print 'SECRET:', encode_privkey(private_key, 'wif')
    else:
      print 'compressed SHARE:', address_c
      print 'compressed SECRET:', encode_privkey(private_key, 'wif_compressed')
      print 'uncompressed SHARE', address_u
      print 'uncompressed SECRET:', encode_privkey(private_key, 'wif')
    print ''
    count += 1
  print 'Found and dumped %d key%s.' % (count, 's' * (count != 1))


if __name__ == '__main__':
  try:
    sys.exit(main(sys.argv))
  except RuntimeError, e:
    print >>sys.stderr, 'fatal: %s' % e
    sys.exit(2)
