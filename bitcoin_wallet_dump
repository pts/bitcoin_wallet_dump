#! /bin/sh
# by pts@fazekas.hu at Thu Oct  2 18:26:04 CEST 2014

""":" #bitcoin_wallet_dump: Dump bitcoin addresses and private keys.

type python2.7 >/dev/null 2>&1 && exec python2.7 -- "$0" ${1+"$@"}
type python2.6 >/dev/null 2>&1 && exec python2.6 -- "$0" ${1+"$@"}
type python2.5 >/dev/null 2>&1 && exec python2.5 -- "$0" ${1+"$@"}
type python2.4 >/dev/null 2>&1 && exec python2.4 -- "$0" ${1+"$@"}
exec python -- ${1+"$@"}; exit 1

Requirements: Python (2.5, 2.6 or 2.7; doesn't work with <=2.3 or 3.x) and,
optionally, for the openssl(1) command-line tool (for decrypting encrypted
wallets).

bitcoin_wallet_dump can dump both compressed and uncompressed SHARE (Bitcoin
address) SECRET (Bitcoin private key) keys found in various wallets. The
output is an ASCII text file containing compressed and uncompressed, SHARE
(base58-encoded Bitcoin address) and SECRET (wif-encoded Bitcoin private
key) keys.

Supported input file formats:

* The wallet file saved by the Bitcoin Wallet
  (https://play.google.com/store/apps/details?id=de.schildbach.wallet&hl=en)
  Android app. The app saves the wallet encrypted. bitcoin_wallet_dump can
  detect it and will call the openssl(1) command-line tool (which will
  prompt the user for the password) to decrypt it. bitcoin_wallet_dump also
  supports dumping the decrypted wallet directly.

* Text files containing SHARE and SECRET strings, including the output of
  bitcoin_wallet_dump itself.

For each private key, the corresponding compressed and uncompressed
addresses (SHARE) will also be generated and dumped.

Please note that some tools accept only uncompressed addresses, and some
tools (such as the Bitcoin Wallet app for Android) display compressed
addresses.
"""

import os
import re
import subprocess
import sys

# --- SHA-256 hash

try:
  # hashlib.new may raise ValueError('unsupported hash type').
  assert __import__('hashlib').new('sha256', 'FooBarBaz').hexdigest() == '4da8b89a905445e96dd0ab6c9be9a72c8b0ffc686a57a3cc6808a8952a3560ed'
  sha256 = lambda data='': __import__('hashlib').new('sha256', data)
except (ImportError, ValueError, AssertionError), e:
  sha256 = None

if sha256 is None:  # E.g. in Python 2.4.
  import struct
  def sha_transform(data, digest):  # Doesn't modify data or digest.
    # Based on http://bitbucket.org/pypy/pypy/raw/c9685aebe8e0996808603169047d43b555816332/lib_pypy/_sha256.py
    # True but slow: len(digest) == 8 and len(data) == 64.
    w = list(struct.unpack('>16L', data))
    for i in xrange(16, 64):
      x, y = w[i - 15], w[i - 2]
      w.append(((((y >> 17) | (y << 15)) ^ ((y >> 19) | (y << 13)) ^ (y >> 10)) + w[i - 7] + (((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)) + w[i - 16]) & 0xffffffff)
    def rnd(a, b, c, d, e, f, g, h, i, j):
      t0 = h + (((e >> 6) | (e << 26)) ^ ((e >> 11) | (e << 21)) ^ ((e >> 25) | (e << 7))) + (g ^ (e & (f ^ g))) + j + w[i]
      t1 = (((a >> 2) | (a << 30)) ^ ((a >> 13) | (a << 19)) ^ ((a >> 22) | (a << 10))) + (((a | b) & c) | (a & b))
      return (d + t0) & 0xffffffff, (t1 + t0) & 0xffffffff
    ss = list(digest)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 0, 0x428a2f98)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 1, 0x71374491)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 2, 0xb5c0fbcf)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 3, 0xe9b5dba5)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 4, 0x3956c25b)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 5, 0x59f111f1)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 6, 0x923f82a4)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 7, 0xab1c5ed5)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 8, 0xd807aa98)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 9, 0x12835b01)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 10, 0x243185be)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 11, 0x550c7dc3)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 12, 0x72be5d74)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 13, 0x80deb1fe)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 14, 0x9bdc06a7)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 15, 0xc19bf174)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 16, 0xe49b69c1)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 17, 0xefbe4786)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 18, 0x0fc19dc6)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 19, 0x240ca1cc)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 20, 0x2de92c6f)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 21, 0x4a7484aa)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 22, 0x5cb0a9dc)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 23, 0x76f988da)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 24, 0x983e5152)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 25, 0xa831c66d)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 26, 0xb00327c8)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 27, 0xbf597fc7)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 28, 0xc6e00bf3)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 29, 0xd5a79147)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 30, 0x06ca6351)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 31, 0x14292967)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 32, 0x27b70a85)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 33, 0x2e1b2138)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 34, 0x4d2c6dfc)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 35, 0x53380d13)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 36, 0x650a7354)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 37, 0x766a0abb)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 38, 0x81c2c92e)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 39, 0x92722c85)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 40, 0xa2bfe8a1)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 41, 0xa81a664b)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 42, 0xc24b8b70)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 43, 0xc76c51a3)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 44, 0xd192e819)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 45, 0xd6990624)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 46, 0xf40e3585)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 47, 0x106aa070)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 48, 0x19a4c116)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 49, 0x1e376c08)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 50, 0x2748774c)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 51, 0x34b0bcb5)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 52, 0x391c0cb3)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 53, 0x4ed8aa4a)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 54, 0x5b9cca4f)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 55, 0x682e6ff3)
    ss[3], ss[7] = rnd(ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], 56, 0x748f82ee)
    ss[2], ss[6] = rnd(ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], 57, 0x78a5636f)
    ss[1], ss[5] = rnd(ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], 58, 0x84c87814)
    ss[0], ss[4] = rnd(ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], ss[4], 59, 0x8cc70208)
    ss[7], ss[3] = rnd(ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], ss[3], 60, 0x90befffa)
    ss[6], ss[2] = rnd(ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], ss[2], 61, 0xa4506ceb)
    ss[5], ss[1] = rnd(ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], ss[1], 62, 0xbef9a3f7)
    ss[4], ss[0] = rnd(ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7], ss[0], 63, 0xc67178f2)
    return tuple((digest[i] + ss[i]) & 0xffffffff for i in xrange(8))
  class sha256(object):
    def __init__(self, data=''):
      self._digest = (0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19)
      self._byte_count = 0  # The lowest 61 bits are significant here.
      self._buf = ''  # Maximum 63 bytes.
      self.update(data)
    def update(self, data):
      if not isinstance(data, (str, buffer)):
        raise TypeError
      size = len(data)
      self._byte_count += size
      if len(self._buf) + size < 64:
        self._buf += str(data)
      else:
        i = 64 - len(self._buf)
        digest = self._digest
        digest = sha_transform(self._buf + str(data[:i]), digest)
        while i + 64 <= size:
          digest = sha_transform(buffer(data, i, 64), digest)
          i += 64
        self._digest = digest
        self._buf = data[i:]  # Always an str.
      # True but slow: assert len(self._buf) < 64
    def digest(self):
      bit_count = self._byte_count << 3
      count = len(self._buf)
      assert count == self._byte_count & 63
      final_data = self._buf + '\x80' + '\0' * (63 - count)
      final_digest = self._digest
      if count >= 64 - 8:
        final_digest = sha_transform(final_data, final_digest)
        final_data = '\0' * 64
      final_data = final_data[:56] + struct.pack('>Q', bit_count & 0xffffffffffffffff)
      final_digest = sha_transform(final_data, final_digest)
      return ''.join(struct.pack('>L', i) for i in final_digest)
    def hexdigest(self):
      return self.digest().encode('hex')
    def copy(self):
      new = sha256.__new__(sha256)
      new._digest = self._digest
      new._byte_count = self._byte_count
      new._buf = self._buf
      return new


def test_sha256():
  assert sha256('Bar' * 335).hexdigest() == (
      '193194dcabf5a8164f07b84ee205b4f0e8bad919d513a25f89a7769edf3bf64d')
  assert sha256('F' * 59).hexdigest() == (
      '55773a51204a61dfca869f41a47a1a63e22eccf2b9973b7706a70dfe77e9bbf7')
  assert sha256('FooBarBaz').hexdigest() == (
      '4da8b89a905445e96dd0ab6c9be9a72c8b0ffc686a57a3cc6808a8952a3560ed')
  assert sha256(buffer('FooBarBaz')).digest() == (
      'M\xa8\xb8\x9a\x90TE\xe9m\xd0\xabl\x9b\xe9\xa7,\x8b\x0f\xfchjW\xa3\xcch'
      '\x08\xa8\x95*5`\xed')
  print 'OK sha-256'


# --- RIPEMD160 hash

try:
  # hashlib.new may raise ValueError('unsupported hash type').
  assert __import__('hashlib').new('ripemd160', 'FooBarBaz').hexdigest() == '211fb67f1d47198e1b42afffcf8a7c53eaefa784'
  ripemd160 = lambda data='': __import__('hashlib').new('ripemd160', data)
except (ImportError, ValueError, AssertionError), e:
  ripemd160 = None

if ripemd160 is None:  # E.g. in Python 2.4 or newer Pythons without OpenSSL.
  # Based on https://maemo.gitorious.org/maemo-pkg/python-crypto/source/8651b0eace17916fe7ba14923dbe4054f255ec2a:lib/Crypto/Hash/RIPEMD160.py
  import struct
  def u32(n): return n & 0xFFFFffff
  rho = [7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]
  pi = [(9*i + 5) & 15 for i in xrange(16)]
  rl = [range(16)]          # id
  rl += [[rho[j] for j in rl[-1]]]  # rho
  rl += [[rho[j] for j in rl[-1]]]  # rho^2
  rl += [[rho[j] for j in rl[-1]]]  # rho^3
  rl += [[rho[j] for j in rl[-1]]]  # rho^4
  rr = [list(pi)]           # pi
  rr += [[rho[j] for j in rr[-1]]]  # rhopi
  rr += [[rho[j] for j in rr[-1]]]  # rho^2 pi
  rr += [[rho[j] for j in rr[-1]]]  # rho^3 pi
  rr += [[rho[j] for j in rr[-1]]]  # rho^4 pi
  f1 = lambda x, y, z: x ^ y ^ z
  f2 = lambda x, y, z: (x & y) | (~x & z)
  f3 = lambda x, y, z: (x | ~y) ^ z
  f4 = lambda x, y, z: (x & z) | (y & ~z)
  f5 = lambda x, y, z: x ^ (y | ~z)
  fl = [f1, f2, f3, f4, f5]
  fr = [f5, f4, f3, f2, f1]
  _shift1 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8]
  _shift2 = [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7]
  _shift3 = [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9]
  _shift4 = [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6]
  _shift5 = [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  sl = [[_shift1[rl[0][i]] for i in xrange(16)]]
  sl.append([_shift2[rl[1][i]] for i in xrange(16)])
  sl.append([_shift3[rl[2][i]] for i in xrange(16)])
  sl.append([_shift4[rl[3][i]] for i in xrange(16)])
  sl.append([_shift5[rl[4][i]] for i in xrange(16)])
  sr = [[_shift1[rr[0][i]] for i in xrange(16)]]
  sr.append([_shift2[rr[1][i]] for i in xrange(16)])
  sr.append([_shift3[rr[2][i]] for i in xrange(16)])
  sr.append([_shift4[rr[3][i]] for i in xrange(16)])
  sr.append([_shift5[rr[4][i]] for i in xrange(16)])
  _kg = lambda x, y: int(2**30 * (y ** (1.0 / x)))
  KL = [
    0,      # Round 1: 0
    _kg(2, 2),  # Round 2: 2**30 * sqrt(2)
    _kg(2, 3),  # Round 3: 2**30 * sqrt(3)
    _kg(2, 5),  # Round 4: 2**30 * sqrt(5)
    _kg(2, 7),  # Round 5: 2**30 * sqrt(7)
  ]
  KR = [
    _kg(3, 2),  # Round 1: 2**30 * cubert(2)
    _kg(3, 3),  # Round 2: 2**30 * cubert(3)
    _kg(3, 5),  # Round 3: 2**30 * cubert(5)
    _kg(3, 7),  # Round 4: 2**30 * cubert(7)
    0,      # Round 5: 0
  ]
  def rol(s, n):
    assert 0 <= s <= 31
    assert 0 <= n <= 0xFFFFffffL
    return u32((n << s) | (n >> (32-s)))
  initial_h = tuple(struct.unpack('<5L', '0123456789ABCDEFFEDCBA9876543210F0E1D2C3'.decode('hex')))
  def box(h, f, k, x, r, s):
    assert len(s) == 16
    assert len(x) == 16
    assert len(r) == 16
    (a, b, c, d, e) = h
    for word in xrange(16):
      T = u32(a + f(b, c, d) + x[r[word]] + k)
      T = u32(rol(s[word], T) + e)
      (b, c, d, e, a) = (T, b, rol(10, c), d, e)
    return (a, b, c, d, e)
  def _ripemd160_compress(h, x):  # x is a list of 16 x 32-bit words
    hl = hr = h
    for round in xrange(5):
      hl = box(hl, fl[round], KL[round], x, rl[round], sl[round])
      hr = box(hr, fr[round], KR[round], x, rr[round], sr[round])
    h = (u32(h[1] + hl[2] + hr[3]),
       u32(h[2] + hl[3] + hr[4]),
       u32(h[3] + hl[4] + hr[0]),
       u32(h[4] + hl[0] + hr[1]),
       u32(h[0] + hl[1] + hr[2]))
    return h
  def ripemd160_compress(h, s):
    assert len(s) % 64 == 0
    p = 0
    while p < len(s):
      h = _ripemd160_compress(h, struct.unpack('<16L', s[p:p+64]))
      p += 64
    assert p == len(s)
    return h
  class ripemd160(object):
    def __init__(self, data=''):
      self._h = initial_h
      self._byte_count = 0    # input size (in bytes)
      self._buf = ''
      self.update(data)
    def update(self, data):
      if not isinstance(data, (str, buffer)):
        raise TypeError
      size = len(data)
      self._byte_count += size
      if len(self._buf) + size < 64:
        self._buf += str(data)
      else:
        i = 64 - len(self._buf)
        self._h = ripemd160_compress(self._h, self._buf + str(data[:i]))
        while i + 64 <= size:
          self._h = ripemd160_compress(self._h, buffer(data, i, 64))
          i += 64
        self._buf = data[i:]  # Always an str.
      # True but slow: assert len(self._buf) < 64
    def digest(self):
      bit_count = (self._byte_count << 3) & 0xffffffffffffffff
      assert len(self._buf) < 64
      data = self._buf + '\x80'
      if len(data) <= 56:
        data = struct.pack('<56sQ', data, bit_count)
      else:
        assert len(data) <= 120
        data = struct.pack('<120sQ', data, bit_count)
      h = ripemd160_compress(self._h, data)
      return struct.pack('<5L', *h)
    def hexdigest(self):
      return self.digest().encode('hex')
    def copy(self):
      obj = self.__class__()
      obj.h = self._h
      obj._byte_count = self._byte_count
      obj._buf = self._buf
      return obj


def test_ripemd160():
  assert ripemd160('FooBarBaz').digest() == (
      '!\x1f\xb6\x7f\x1dG\x19\x8e\x1bB\xaf\xff\xcf\x8a|S\xea\xef\xa7\x84')
  assert ripemd160('FooBarBaz').hexdigest() == (
      '211fb67f1d47198e1b42afffcf8a7c53eaefa784')
  assert ripemd160(buffer('FooBarBaz')).hexdigest() == (
      '211fb67f1d47198e1b42afffcf8a7c53eaefa784')
  r = ripemd160('Food')
  for i in xrange(0, 100, 2):
    r.update('Bar' * i)
    r.update(buffer('Baz' * (i + 1)))
  assert r.hexdigest() == '67008e9518b6dd9f5ed7bd9aa4eb79660c15a232'
  print 'OK ripemd160'


# --- Bitcoin crypto code.
#
# Based on:
# https://github.com/vbuterin/pybitcointools/blob/master/bitcoin/main.py
#
# TODO(pts): Remove unused code.

# Elliptic curve parameters (secp256k1)

P = 2**256 - 2**32 - 977
N = 115792089237316195423570985008687907852837564279074904382605163141518161494337
A = 0
B = 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)


def change_curve(p, n, a, b, gx, gy):
    global P, N, A, B, Gx, Gy, G
    P, N, A, B, Gx, Gy = p, n, a, b, gx, gy
    G = (Gx, Gy)


def getG():
    return G

# Extended Euclidean Algorithm


def inv(a, n):
    lm, hm = 1, 0
    low, high = a % n, n
    while low > 1:
        r = high/low
        nm, new = hm-lm*r, high-low*r
        lm, low, hm, high = nm, new, lm, low
    return lm % n

# Base switching
code_strings = {
    2: '01',
    10: '012356789',
    16: '0123456789abcdef',
    32: 'abcdefghijklmnopqrstuvwxyz234567',
    58: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
    256: ''.join(chr(x) for x in xrange(256))
}


def get_code_string(base):
    if base in code_strings:
        return code_strings[base]
    else:
        raise ValueError("Invalid base!")


def lpad(msg, symbol, length):
    if len(msg) >= length:
        return msg
    return symbol * (length - len(msg)) + msg


def encode(val, base, minlen=0):
    base, minlen = int(base), int(minlen)
    code_string = get_code_string(base)
    result = ""
    while val > 0:
        result = code_string[val % base] + result
        val /= base
    return lpad(result, code_string[0], minlen)


def decode(string, base):
    base = int(base)
    code_string = get_code_string(base)
    result = 0
    if base == 16:
        string = string.lower()
    while len(string) > 0:
        result *= base
        result += code_string.find(string[0])
        string = string[1:]
    return result


def changebase(string, frm, to, minlen=0):
    if frm == to:
        return lpad(string, get_code_string(frm)[0], minlen)
    return encode(decode(string, frm), to, minlen)

# Elliptic curve Jordan form functions
# P = (m, n, p, q) where m/n = x, p/q = y

def isinf(p):
    return p[0] == 0 and p[1] == 0


def jordan_isinf(p):
    return p[0][0] == 0 and p[1][0] == 0


def mulcoords(c1, c2):
    return (c1[0] * c2[0] % P, c1[1] * c2[1] % P)


def mul_by_const(c, v):
    return (c[0] * v % P, c[1])


def addcoords(c1, c2):
    return ((c1[0] * c2[1] + c2[0] * c1[1]) % P, c1[1] * c2[1] % P)


def subcoords(c1, c2):
    return ((c1[0] * c2[1] - c2[0] * c1[1]) % P, c1[1] * c2[1] % P)


def invcoords(c):
    return (c[1], c[0])


def jordan_add(a, b):
    if jordan_isinf(a):
        return b
    if jordan_isinf(b):
        return a

    if (a[0][0] * b[0][1] - b[0][0] * a[0][1]) % P == 0:
        if (a[1][0] * b[1][1] - b[1][0] * a[1][1]) % P == 0:
            return jordan_double(a)
        else:
            return ((0, 1), (0, 1))
    xdiff = subcoords(b[0], a[0])
    ydiff = subcoords(b[1], a[1])
    m = mulcoords(ydiff, invcoords(xdiff))
    x = subcoords(subcoords(mulcoords(m, m), a[0]), b[0])
    y = subcoords(mulcoords(m, subcoords(a[0], x)), a[1])
    return (x, y)


def jordan_double(a):
    if jordan_isinf(a):
        return ((0, 1), (0, 1))
    num = addcoords(mul_by_const(mulcoords(a[0], a[0]), 3), (A, 1))
    den = mul_by_const(a[1], 2)
    m = mulcoords(num, invcoords(den))
    x = subcoords(mulcoords(m, m), mul_by_const(a[0], 2))
    y = subcoords(mulcoords(m, subcoords(a[0], x)), a[1])
    return (x, y)


def jordan_multiply(a, n):
    if jordan_isinf(a) or n == 0:
        return ((0, 0), (0, 0))
    if n == 1:
        return a
    if n < 0 or n >= N:
        return jordan_multiply(a, n % N)
    if (n % 2) == 0:
        return jordan_double(jordan_multiply(a, n/2))
    if (n % 2) == 1:
        return jordan_add(jordan_double(jordan_multiply(a, n/2)), a)


def to_jordan(p):
    return ((p[0], 1), (p[1], 1))


def from_jordan(p):
    return (p[0][0] * inv(p[0][1], P) % P, p[1][0] * inv(p[1][1], P) % P)
    return (p[0][0] * inv(p[0][1], P) % P, p[1][0] * inv(p[1][1], P) % P)


def fast_multiply(a, n):
    return from_jordan(jordan_multiply(to_jordan(a), n))


def fast_add(a, b):
    return from_jordan(jordan_add(to_jordan(a), to_jordan(b)))

# Functions for handling pubkey and privkey formats


def get_pubkey_format(pub):
    if isinstance(pub, (tuple, list)): return 'decimal'
    elif len(pub) == 65 and pub[0] == '\x04': return 'bin'
    elif len(pub) == 130 and pub[0:2] == '04': return 'hex'
    elif len(pub) == 33 and pub[0] in ['\x02', '\x03']: return 'bin_compressed'
    elif len(pub) == 66 and pub[0:2] in ['02', '03']: return 'hex_compressed'
    elif len(pub) == 64: return 'bin_electrum'
    elif len(pub) == 128: return 'hex_electrum'
    else: raise Exception("Pubkey not in recognized format")


def encode_pubkey(pub, formt):
    if not isinstance(pub, (tuple, list)):
        pub = decode_pubkey(pub)
    if formt == 'decimal': return pub
    elif formt == 'bin': return '\x04' + encode(pub[0], 256, 32) + encode(pub[1], 256, 32)
    elif formt == 'bin_compressed': return chr(2+(pub[1] % 2)) + encode(pub[0], 256, 32)
    elif formt == 'hex': return '04' + encode(pub[0], 16, 64) + encode(pub[1], 16, 64)
    elif formt == 'hex_compressed': return '0'+str(2+(pub[1] % 2)) + encode(pub[0], 16, 64)
    elif formt == 'bin_electrum': return encode(pub[0], 256, 32) + encode(pub[1], 256, 32)
    elif formt == 'hex_electrum': return encode(pub[0], 16, 64) + encode(pub[1], 16, 64)
    else: raise Exception("Invalid format!")


def decode_pubkey(pub, formt=None):
    if not formt: formt = get_pubkey_format(pub)
    if formt == 'decimal': return pub
    elif formt == 'bin': return (decode(pub[1:33], 256), decode(pub[33:65], 256))
    elif formt == 'bin_compressed':
        x = decode(pub[1:33], 256)
        beta = pow(x*x*x+A*x+B, (P+1)/4, P)
        if (beta + ord(pub[0])) & 1:
          y = P - beta
        else:
          y = beta
        return (x, y)
    elif formt == 'hex': return (decode(pub[2:66], 16), decode(pub[66:130], 16))
    elif formt == 'hex_compressed':
        return decode_pubkey(pub.decode('hex'), 'bin_compressed')
    elif formt == 'bin_electrum':
        return (decode(pub[:32], 256), decode(pub[32:64], 256))
    elif formt == 'hex_electrum':
        return (decode(pub[:64], 16), decode(pub[64:128], 16))
    else: raise Exception("Invalid format!")

def get_privkey_format(priv):
    if isinstance(priv, (int, long)): return 'decimal'
    elif len(priv) == 32: return 'bin'
    elif len(priv) == 33: return 'bin_compressed'
    elif len(priv) == 64: return 'hex'
    elif len(priv) == 66: return 'hex_compressed'
    else:
        bin_p = b58check_to_bin(priv)
        if len(bin_p) == 32: return 'wif'
        elif len(bin_p) == 33: return 'wif_compressed'
        else: raise Exception("WIF does not represent privkey")

def encode_privkey(priv, formt, vbyte=0):
    if not isinstance(priv, (int, long)):
        return encode_privkey(decode_privkey(priv), formt, vbyte)
    if formt == 'decimal': return priv
    elif formt == 'bin': return encode(priv, 256, 32)
    elif formt == 'bin_compressed': return encode(priv, 256, 32)+'\x01'
    elif formt == 'hex': return encode(priv, 16, 64)
    elif formt == 'hex_compressed': return encode(priv, 16, 64)+'01'
    elif formt == 'wif':
        return bin_to_b58check(encode(priv, 256, 32), 128+int(vbyte))
    elif formt == 'wif_compressed':
        return bin_to_b58check(encode(priv, 256, 32)+'\x01', 128+int(vbyte))
    else: raise Exception("Invalid format!")

def decode_privkey(priv,formt=None):
    if not formt: formt = get_privkey_format(priv)
    if formt == 'decimal': return priv
    elif formt == 'bin': return decode(priv, 256)
    elif formt == 'bin_compressed': return decode(priv[:32], 256)
    elif formt == 'hex': return decode(priv, 16)
    elif formt == 'hex_compressed': return decode(priv[:64], 16)
    else:
        bin_p = b58check_to_bin(priv)
        if len(bin_p) == 32: return decode(bin_p, 256)
        elif len(bin_p) == 33: return decode(bin_p[:32], 256)
        else: raise Exception("WIF does not represent privkey")

def add_pubkeys(p1, p2):
    f1, f2 = get_pubkey_format(p1), get_pubkey_format(p2)
    return encode_pubkey(fast_add(decode_pubkey(p1, f1), decode_pubkey(p2, f2)), f1)

def add_privkeys(p1, p2):
    f1, f2 = get_privkey_format(p1), get_privkey_format(p2)
    return encode_privkey((decode_privkey(p1, f1) + decode_privkey(p2, f2)) % N, f1)


def multiply(pubkey, privkey):
    f1, f2 = get_pubkey_format(pubkey), get_privkey_format(privkey)
    pubkey, privkey = decode_pubkey(pubkey, f1), decode_privkey(privkey, f2)
    # http://safecurves.cr.yp.to/twist.html
    if not isinf(pubkey) and (pubkey[0]**3+B-pubkey[1]*pubkey[1]) % P != 0:
        raise Exception("Point not on curve")
    return encode_pubkey(fast_multiply(pubkey, privkey), f1)


def divide(pubkey, privkey):
    factor = inv(decode_privkey(privkey), N)
    return multiply(pubkey, factor)


def compress(pubkey):
    f = get_pubkey_format(pubkey)
    if 'compressed' in f: return pubkey
    elif f == 'bin': return encode_pubkey(decode_pubkey(pubkey, f), 'bin_compressed')
    elif f == 'hex' or f == 'decimal':
        return encode_pubkey(decode_pubkey(pubkey, f), 'hex_compressed')


def decompress(pubkey):
    f = get_pubkey_format(pubkey)
    if 'compressed' not in f: return pubkey
    elif f == 'bin_compressed': return encode_pubkey(decode_pubkey(pubkey, f), 'bin')
    elif f == 'hex_compressed' or f == 'decimal':
        return encode_pubkey(decode_pubkey(pubkey, f), 'hex')


def privkey_to_pubkey(privkey):
    f = get_privkey_format(privkey)
    privkey = decode_privkey(privkey, f)
    if privkey == 0 or privkey >= N:
        raise Exception("Invalid privkey")
    if f in ['bin', 'bin_compressed', 'hex', 'hex_compressed', 'decimal']:
        return encode_pubkey(fast_multiply(G, privkey), f)
    else:
        return encode_pubkey(fast_multiply(G, privkey), f.replace('wif', 'hex'))

def privkey_to_address(priv, magicbyte=0):
    return pubkey_to_address(privkey_to_pubkey(priv), magicbyte)

# Hashes

def bin_hash160(string):
    return ripemd160(sha256(string).digest()).digest()


def bin_sha256(string):
    return sha256(string).digest()


def bin_dbl_sha256(string):
    return sha256(sha256(string).digest()).digest()


def dbl_sha256(string):
    return bin_dbl_sha256(string).encode('hex')


# Encodings

def bin_to_b58check(inp, magicbyte=0):
    inp_fmtd = chr(int(magicbyte)) + inp
    leadingzbytes = len(re.match('^\x00*', inp_fmtd).group(0))
    checksum = bin_dbl_sha256(inp_fmtd)[:4]
    return '1' * leadingzbytes + changebase(inp_fmtd+checksum, 256, 58)


def b58check_to_bin(inp):
    leadingzbytes = len(re.match('^1*', inp).group(0))
    data = '\x00' * leadingzbytes + changebase(inp, 58, 256)
    assert bin_dbl_sha256(data[:-4])[:4] == data[-4:]
    return data[1:-4]


def get_version_byte(inp):
    leadingzbytes = len(re.match('^1*', inp).group(0))
    data = '\x00' * leadingzbytes + changebase(inp, 58, 256)
    assert bin_dbl_sha256(data[:-4])[:4] == data[-4:]
    return ord(data[0])


def hex_to_b58check(inp, magicbyte=0):
    return bin_to_b58check(inp.decode('hex'), magicbyte)


def b58check_to_hex(inp):
    return b58check_to_bin(inp).encode('hex')


def pubkey_to_address(pubkey, magicbyte=0):
    if isinstance(pubkey, (list, tuple)):
        pubkey = encode_pubkey(pubkey, 'bin')
    if len(pubkey) in (66, 130):
        return bin_to_b58check(bin_hash160(pubkey.decode('hex')), magicbyte)
    return bin_to_b58check(bin_hash160(pubkey), magicbyte)

def is_corresponding(address, public_key):
  address_c = pubkey_to_address(encode_pubkey(public_key, 'bin_compressed'))
  address_u = pubkey_to_address(public_key)
  return address in (address_c, address_u)

# --- Tests for the Bitcoin crypto code above

def test_crypto():
  """Test data from: http://bitcoin.stackexchange.com/a/3839/19559 """
  privu = '5HwoXVkHoRM8sL2KmNRS217n1g8mPPBomrY7yehCuXC1115WWsh'
  assert get_privkey_format(privu) == 'wif'
  dprivu = decode_privkey(privu)
  assert dprivu == 7719472615821079694904732333912527190217998977709370935963838933860875309329
  dpubu = privkey_to_pubkey(dprivu)
  assert dpubu == (35826991941973211494003564265461426073026284918572421206325859877044495085994, 25491041833361137486709012056693088297620945779048998614056404517283089805761)
  pubu = '044f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa385b6b1b8ead809ca67454d9683fcf2ba03456d6fe2c4abe2b07f0fbdbb2f1c1'
  assert get_pubkey_format(pubu) == 'hex'
  assert encode_pubkey(dpubu, 'hex') == pubu
  daddru = pubkey_to_address(dpubu)
  assert daddru == '1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a'
  # There is no way to convert an address (e.g. daddru) back to a public or
  # private key. (That's because the address is computed from the public key
  # by hashing.)
  privc = 'KwntMbt59tTsj8xqpqYqRRWufyjGunvhSyeMo3NTYpFYzZbXJ5Hp'
  assert get_privkey_format(privc) == 'wif_compressed'
  assert decode_privkey(privc) == dprivu
  assert encode_pubkey(dpubu, 'hex_compressed') == '034f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa'
  assert encode_pubkey(dpubu, 'hex_electrum') == '4f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa385b6b1b8ead809ca67454d9683fcf2ba03456d6fe2c4abe2b07f0fbdbb2f1c1'
  assert pubkey_to_address(encode_pubkey(dpubu, 'bin_compressed')) == '1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9'


test_crypto()


# --- Parser of http://bitcoinj.googlecode.com/git/core/src/bitcoin.proto


class ProtoParseError(ValueError):
  """Input protocol message is invalid."""


class TruncatedError(ProtoParseError):
  """Input protocol message was truncated."""


class UsageError(ProtoParseError):
  """Error in the command-line."""


def parse_varint(data, i, j):
  assert 0 <= i <= j
  u = 0
  shift = 0
  while True:
    if i >= j:
      raise TruncatedError
    if i >= len(data):
      raise TruncatedError
    c = ord(data[i])
    i += 1
    if c < 128:
      u |= c << shift
      return u, i
    u |= (c & 127) << shift  # LSB first.
    shift += 7


def parse_proto(data, start=0, end=None):
  if not isinstance(data, str):
    raise TypeError
  if end is None:
    end = len(data)
  if not (0 <= start <= end):
    raise ValueError, (start, end)
  i, j = start, end
  result = {}
  prev_tag = None
  while i < j:
    i0 = i
    u, i = parse_varint(data, i, j)
    tag = u >> 3
    type = u & 7
    tr = result.get(tag)
    if tag != prev_tag and tr is not None:
      # TODO(pts): Make groups work.
      raise ProtoParseError('Unexpected tag again.')
    if tr is None:
      tr = result[tag] = []
    if type == 2:  # Length-delimited.
      u, i = parse_varint(data, i, j)
      if i + u > j:
        raise TruncatedError
      # TODO(pts): Use the buffer type to avoid string copies.
      tr.append({'at': i0, 'ofs': i, 'data': data[i : i + u]})
      i += u
    elif type == 0:  # Varint.
      u, i = parse_varint(data, i, j)
      tr.append({'at': i0, 'varint': u})
    elif type == 3:  # Start-group.
      tr.append({'at': i0, 'start': True})
    elif type == 4:  # End-group.
      tr.append({'at': i0, 'end': True})
    elif type == 5:  # 32-bit.
      if i + 4 > j:
        raise TruncatedError
      u = struct.unpack('<I', data[i : i + 4])[0]
      tr.append({'at': i0, 'f32': u})
      i += 4
    elif type == 1:  # 64-bit.
      if i + 8 > j:
        raise TruncatedError
      u = struct.unpack('<Q', data[i : i + 8])[0]
      tr.append({'at': i0, 'f64': u})
      i += 8
    else:
      raise ProtoParseError('@%d tag=%d type=%d' % (i0, tag, type))
    prev_tag = tag
  return result


def get_required(msg, tag):
  v = msg.get(tag, None)
  assert v is not None
  assert len(v) == 1
  return v[0]

def cescape_str(text, as_utf8=False):
  # Copied from google/protobuf/text_format.py.
  def escape(c):
    o = ord(c)
    if o == 10: return r"\n"   # optional escape
    if o == 13: return r"\r"   # optional escape
    if o ==  9: return r"\t"   # optional escape
    if o == 39: return r"\'"   # optional escape

    if o == 34: return r'\"'   # necessary escape
    if o == 92: return r"\\"   # necessary escape

    # necessary escapes
    if not as_utf8 and (o >= 127 or o < 32): return "\\%03o" % o
    return c
  return "".join([escape(c) for c in text])


def parse_bitcoin_wallet_proto(data):
  TAG_WALLET_NETWORK_IDENTIFIER = 1
  TAG_WALLET_KEY = 3
  TAG_KEY_TYPE = 1
  TAG_KEY_PRIVATE_KEY = 2
  TAG_KEY_PUBLIC_KEY = 3
  ENUM_KEY_TYPE_ORIGINAL = 1

  msg_wallet = parse_proto(data)
  assert get_required(msg_wallet, TAG_WALLET_NETWORK_IDENTIFIER)['data'] in (
      'org.bitcoin.production', 'org.bitcoin.test')
  for data_key in msg_wallet.get(TAG_WALLET_KEY, ()):
    msg_key = parse_proto(data_key['data'])
    key_type = get_required(msg_key, TAG_KEY_TYPE)
    assert key_type['varint'] == ENUM_KEY_TYPE_ORIGINAL
    private_key = get_required(msg_key, TAG_KEY_PRIVATE_KEY)['data']
    # TODO(pts): Generate it from the private key if mossing.
    public_key = get_required(msg_key, TAG_KEY_PUBLIC_KEY)['data']
    pubkey_format = get_pubkey_format(public_key)
    assert pubkey_format in ('bin', 'bin_compressed')
    # Ignore get_privkey_format(private_key), it's always 'bin', never
    # 'bin_compressed' if the proto was created by the Android app named
    # Bitcoin Wallet.
    is_compressed = pubkey_format == 'bin_compressed'
    assert get_privkey_format(private_key) == 'bin'
    private_key = decode_privkey(private_key)
    public_key = decode_pubkey(public_key)
    assert privkey_to_pubkey(private_key) == public_key
    yield {'private_key': private_key,
           'public_key': public_key,
           'is_compressed': is_compressed,
          }

def parse_bitcoin_wallet_proto_enc_custom(data, extra_flags):
  # TODO(pts): Use `-pass', read passphrase in Python, customize prompt.
  p = subprocess.Popen(
      ('openssl', 'enc', '-d', '-aes-256-cbc') + tuple(extra_flags),
      stdin=subprocess.PIPE, stdout=subprocess.PIPE)
  plaintext_data = p.communicate(data)[0]
  exit_code = p.wait()
  if exit_code:
    raise RuntimeError(
        'openssl decryption failed with exit_code=%d' % exit_code)
  plaintext_format = detect(plaintext_data)
  if plaintext_format != 'bitcoin_wallet_proto':
    raise RuntimeError(
        'Unexpected plaintext format, expecting bitcoin_wallet_proto: %s' %
        plaintext_format)
  return parse_bitcoin_wallet_proto(plaintext_data)


def parse_bitcoin_wallet_proto_enc(data):
  return parse_bitcoin_wallet_proto_enc_custom(data, ())


def parse_bitcoin_wallet_proto_enc_base64(data):
  return parse_bitcoin_wallet_proto_enc_custom(data, ('-a',))


# From https://en.bitcoin.it/wiki/Private_key#Base58_Wallet_Import_format :
#
# WIF: For private keys associated with uncompressed public keys, they are
# 51 characters and always start with the number 5 on mainnet (9 on
# testnet). Private keys associated with compressed public keys are 52
# characters and start with a capital L or K on mainnet (c on testnet). This
# is the same private key in (mainnet) wallet import format.
PRIVATE_KEY_RE = re.compile(
    r'[59][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{50}\Z|'
    r'[LKc][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51}\Z')

# From https://en.bitcoin.it/wiki/Address :
#
# A Bitcoin address, or simply address, is an identifier of 26-34
# alphanumeric characters, beginning with the number 1 or 3 on mainnet (and
# m or n on testnet), that represents a possible destination for a Bitcoin
# payment.
#
# It's not possible to know whether an address is compressed or not.
ADDRESS_RE = re.compile(
    r'[13mn]'
    r'[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25,33}\Z')


BASE58_DATA_RE = re.compile(
    r'\s*(?:[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{26,52}'
    r'\s*)*\Z')


def parse_text(data):
  items = []
  prev_address = prev_private_key = None
  for line in data.splitlines():
    line = line.split()
    if not line:
      prev_address = prev_private_key = None
    if '#' in line:
      del line[line.index('#'):]
    if (not line or line[0].startswith('#') or
        line[0] == 'input_format:'):
      continue
    if PRIVATE_KEY_RE.match(line[-1]):
      private_key_format = get_privkey_format(line[-1])
      if private_key_format not in ('wif', 'wif_compressed'):
        raise ValueError(
            'Unexpected private key format, expecting wif*: %s' %
            private_key_format)
      private_key = decode_privkey(line[-1])
      public_key = privkey_to_pubkey(private_key)
      if is_corresponding(prev_address, public_key):
        assert items
        assert 'address' in items[-1]
        assert items[-1]['address'] == prev_address
        items.pop()
      if prev_private_key != private_key:
        items.append({'private_key': private_key,
                      'public_key': public_key,
                      'is_compressed': private_key_format == 'wif_compressed'})
      prev_address = None
      prev_private_key = private_key
    elif ADDRESS_RE.match(line[-1]):
      if prev_private_key is not None and (
          items and 'private_key' in items[-1] and
          is_corresponding(
              line[-1], privkey_to_pubkey(items[-1]['private_key']))):
        pass
      else:
        items.append({'address': line[-1]})
        prev_address = line[-1]
        prev_private_key = None
  return iter(items)


PARSERS = {
    'bitcoin_wallet_proto': parse_bitcoin_wallet_proto,
    'bitcoin_wallet_proto_enc': parse_bitcoin_wallet_proto_enc,
    'bitcoin_wallet_proto_enc_base64': parse_bitcoin_wallet_proto_enc_base64,
    'text': parse_text,
}


def detect(data):
  if (data.startswith('\n\x16org.bitcoin.production') or
      data.startswith('\n\x10org.bitcoin.test')
     ):
    return 'bitcoin_wallet_proto'
  elif data.startswith('Salted__'):
    return 'bitcoin_wallet_proto_enc'
  elif data.startswith('U2FsdGVkX1'):  # base64.b64encode('Salted__')[:10].
    return 'bitcoin_wallet_proto_enc_base64'
  elif (data.startswith('input_format:') or
        data.startswith('SHARE:') or
        data.startswith('SECRET:')):
    return 'text'
  elif BASE58_DATA_RE.match(data):
    return 'text'
  else:
    return 'unknown'


def improve(bkeys):
  """Yields ckeys from bkeys."""
  for bkey in bkeys:
    private_key = bkey.get('private_key')
    address = bkey.get('address')
    public_key = bkey.get('public_key')
    is_compressed = bkey.get('is_compressed')
    address_c = address_u = None
    if private_key is not None:
      private_key_format = get_privkey_format(private_key)
      assert private_key_format == 'decimal'
      public_key_gen = privkey_to_pubkey(private_key)
      if public_key is None:
        public_key = public_key_gen
      elif public_key_gen != public_key:
        raise ValueError(
            'Unexpected public key: expected=%s, got=%s' %
            (encode_pubkey(public_key, 'hex'),
             encode_pubkey(publig_key_gen, 'hex')))
    if public_key is not None:
      address_c = pubkey_to_address(encode_pubkey(public_key, 'bin_compressed'))
      address_u = pubkey_to_address(public_key)
      if address not in (None, address_c, address_u):
        raise ValueError('Unexpected Bitcoin address: %s' % address)
      if is_compressed:  # None and False re false.
        address = address_c
      else:
        address = address_u
    assert address is not None
    ckey = {}
    if private_key is not None:
      ckey['private_key'] = private_key
    if public_key is not None:
      ckey['public_key'] = public_key
    if is_compressed is not None:
      ckey['is_compressed'] = is_compressed
    if address_c is not None:
      ckey['address_c'] = address_c
    if address_u is not None:
      ckey['address_u'] = address_u
    if address_c is None and address_u is None and address is not None:
      ckey['address'] = address
    yield ckey


def dump_text(ckeys, format):
  print 'input_format: %s\n' % format
  count = 0
  for ckey in ckeys:
    private_key = ckey.get('private_key')
    address_c = ckey.get('address_c')
    address_u = ckey.get('address_u')
    public_key = ckey.get('public_key')
    is_compressed = ckey.get('is_compressed')
    if is_compressed is None:
      print 'SHARE:', ckey['address']
      if private_key is not None:
        print 'SECRET:', encode_privkey(private_key, 'wif')
    else:
      print 'compressed SHARE:', address_c
      print 'compressed SECRET:', encode_privkey(private_key, 'wif_compressed')
      print 'uncompressed SHARE', address_u
      print 'uncompressed SECRET:', encode_privkey(private_key, 'wif')
    print ''
    count += 1
  print 'Found and dumped %d key%s.' % (count, 's' * (count != 1))


def dump_bitcoin_wallet_proto_ascii(ckeys, format):
  print 'network_identifier: "org.bitcoin.production"'  # TODO(pts): .test?
  print '# http://bitcoinj.googlecode.com/git/core/src/bitcoin.proto'
  print 'version: 0'
  print 'encryption_type: UNENCRYPTED'
  print 'key_rotation_time: 0'
  # last_seen_block_height: 323508
  # last_seen_block_time_secs: 1412259683
  print '# input_format: %s\n' % format
  count = 0
  for ckey in ckeys:
    private_key = ckey.get('private_key')
    public_key = ckey.get('public_key')
    is_compressed = ckey.get('is_compressed')
    if private_key is None:
      print '# SHARE:', ckey['address']
    else:
      iic = repr(bool(is_compressed)).lower()
      print 'key {'
      print '  type: ORIGINAL'
      print '  # input_is_compressed: ' + iic
      print '  # is_compressed: true'
      print '  private_key: "%s"' % cescape_str(encode_privkey(
          private_key, 'bin'))
      print '  public_key: "%s"' % cescape_str(encode_pubkey(
          public_key, 'bin_compressed'))
      print '  #creation_timestamp: 1401805973000'
      print '}'
      print 'key {'
      print '  type: ORIGINAL'
      print '  # input_is_compressed: ' + iic
      print '  # is_compressed: false'
      print '  private_key: "%s"' % cescape_str(encode_privkey(
          private_key, 'bin'))
      print '  public_key: "%s"' % cescape_str(encode_pubkey(public_key, 'bin'))
      print '  #creation_timestamp: 1401805973000'
      print '}\n'
    count += 1
  print '# Found and dumped %d key%s.' % (count, 's' * (count != 1))


DUMPERS = {
    'text': dump_text,
    'bitcoin_wallet_proto_ascii': dump_bitcoin_wallet_proto_ascii,
}

def main(argv):
  if len(argv) < 2 or argv[1] == '--help':
    raise UsageError(
        'Usage: %s [<flag>...] [<input-filename> ...]\n' % argv[0] +
        'Flags:\n'
        '--output-format=text\n'
        '--output-format=bitcoin_wallet_proto_ascii')
  output_format = 'text'
  i = 1
  while i < len(argv):
    arg = argv[i]
    if arg == '-' or not arg.startswith('-'):
      break
    i += 1
    if arg == '--':
      break
    arg = arg.lstrip('-')
    if arg.startswith('output-format='):
      value = arg.split('=', 1)[1]
      if value in ('text', 'bitcoin_wallet_proto_ascii'):
        output_format = value
      else:
        raise UsageError('Unknown flag value: --output-format=%s' % value)
    else:
      raise UsageError('Unknown flag: --%s' % arg)
  for filename in argv[i:]:
    if filename == '-':
      data = sys.stdin.read()
    else:
      data = open(filename).read()
    format = detect(data)
    if format == 'unknown':
      raise RuntimeError('Could not detect file format: %s' % filename)
    dumper = DUMPERS[output_format]
    dumper(improve(PARSERS[format](data)), format)


if __name__ == '__main__':
  try:
    sys.exit(main(sys.argv))
  except RuntimeError, e:
    print >>sys.stderr, 'fatal: %s' % e
    sys.exit(2)
  except UsageError, e:
    print >>sys.stderr, 'fatal: %s' % e
    sys.exit(1)
